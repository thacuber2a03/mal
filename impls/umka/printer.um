import (
	"std.um"

	"types.um"
)

fn prStr*(v: types::Object, readable: bool): str

fn escape(s: str): str {
	var res: str

	for i,c in s {
		switch c {
		case '"': res += "\\\""
		case '\\': res += "\\\\"
		case '\n': res += "\\n"
		case '\r': res += "\\r"
		case '\t': res += "\\t"
		default: res += c
		}
	}

	return res
}

fn prStr*(v: types::Object, readable: bool): str {
	switch v := type(v) {
	case types::Num:
		return sprintf("%g", v)
	case types::String:
		if v.keyword { return ':' + v.value }
		if !readable { return '"' + escape(v.value) + '"' }
		return v.value
	case types::Sym:
		return v
	case types::Nil:
		return "nil"
	case types::Bool:
		return sprintf("%v", v)
	case types::List:
		s := v.vector ? "[" : "("
		for i, val in v.data {
			s += prStr(val, readable)
			if i < len(v.data)-1 { s += " " }
		}
		return s + (v.vector ? "]" : ")")
	case types::HashMap:
		s := "{"
		ks := keys(v)
		for i, k in ks {
			v := v[k]
			s += sprintf("%s %s", prStr(k, readable), prStr(v, readable))
			if i < len(ks)-1 { s += " " }
		}
		return s + "}"

	case types::PrimFn:
		return "<primitive>"

	case types::Error:
		return sprintf("error: %s", v.msg)
	}

	std::assert(false, sprintf("unreachable case for value %+v", v))
	return ""
}
